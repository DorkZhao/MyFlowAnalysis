{"name":"Myflowanalysis","tagline":"Flow analysis using Soot","body":"### Welcome to Project Pages.\r\nHere are the daily working logs. \r\n\r\n### 11 03\r\n15 45UML目标驱动:\r\n找到所有的敏感permission并追踪到触发permission的ui components\r\n1. 找到所有敏感permission: PscoutMethod\r\n2. 追踪到触发UI18 25AppContext是1. 如何找到所有permission的\r\n２. 如何追踪到所有context的\r\n\r\n18 27MyMainTest.Main: runAnalysis用于调用taint analysis相比Test.Main(): \r\n1. Taint Analysis保留，除了少了repeat count\r\n2. 多了permission analysis()18 47permission analysis: analyzeCGanalyzeCG: bfs遍历call graph，如果发现敏感方法，把它映射到permission, 加到perInvoc中18 58setContext没发现被谁调用了\r\n19 02isSameStmt在analyzeFlowResult中出现了\r\n19 16跑了下app context~/workspace/AppContext$ python Main.py ApkSamples /home/hao/Android/Sdk/platforms\r\n没有结果\r\n为什么会出现None None19 29AppContext里的dare无法运行，去官网下了个替换后好了但是FactorResult还是空空如也\r\n发现了错误文件　insufficient memory for the Java Runtime Environment to continue\r\n难怪跑不了，main上写的是40G内存空间19 36跑一下\r\n19 40Unable to open '/home/hao/workspace/AppContext/Instrument/InstrumentedApp/ApkSamples/de.robv.android.xposed.installer_v33_36570c.apk' as zip archive\r\n在retargeting阶段报错，不知是dare的问题还是怎么的\r\n\r\n等等　这目录不对啊\r\n19 41\r\n/InstrumentedApp/ApkSamples下发现了错误文件\r\nAndroid platform directory you havespecified (/home/hao/Android/Sdk/platform) does not exist\r\n看来android platform没指定对19 49dare必须得是android-15, 把16重命名为１５看下效果\r\n20 34None None和０是调用Command类输出的０表示没有错误\r\n\r\n20 37AppContext输入apk -ifstmtinstrument-> 嵌入代码了的apk --apktool-> .dex --dare-> .class --ICC-> --factor-> output.csv, CG2.log \r\n21 02ICC那块报错\r\n\r\n### 10 01\r\n08 58为什么callbacks能不断推进？ paper里解释\"since callback handlers are free to register new callbacks on their own\"不在这上面浪费时间了。流程大致是一个worklist算法：初始时扫描app（从resource.arsc里）四大组件包含的类里的callback并存到queue里。每次对queue里存的callback method寻找可抵达的新callback函数，找到后加到queue里作为下次寻找可抵达函数的入口。循环直到queue为空。\r\n09 19\r\nSetupApplication.calculateSourcesSinksEntrypoints\r\n整体流程: setup app路径，lib jar等 -> \r\n09 36 \r\nOptions用于Soot cmd 选项设置\r\n\r\n09 58\r\nappcontext前面和flowdroid一样，只是在运行完taint analysis后，增加了一个permissionAnalysis\r\npermissionAnalysis主体是一个发生在wjtp.checkCG的transform，即基于call graph的操作。核心函数是analyzeCG().\r\n\r\n\r\n10 01\r\nSootMethod和MethodOrMethodContext有啥区别？\r\n\r\n10 28     \r\nanalyzeCG() 遍历call graph里所有边，如果发现了包含在了Pscount的敏感函数就新建一个相应PermissionInvocation。如果此perInvoc没有分析过（有个list存分析过得），即调用analyzeFlowResult进行分析PermissionInvocation是敏感函数的wrapper14 14\r\n这段的context指的是啥\r\n\r\n14 46\r\nContext是在printCFGpath赋值的，位于analyzeCG里，差点漏了过去有两个cfg, 一个cfg一个icfg, 貌似分别对应inner和inter\r\n15 11\r\nanalyzeCG iterate edge，并对每条edge调用printCFGPath, 在printCFGPath内部则检查关联入边的语句, 对每条语句再调用多态的printCFGpath \r\n在对于unit的printCFGpath内，创建了两个Queue, 分别存语句和入边所代表的函数。\r\n\r\n### 09 29\r\n10 08\t继续MyTest\t\r\n比原FlowDroid多了个permissionAnalysis。\r\n其中第一句是MySetupApplication\r\n10 54\r\nMySetupApplication中的calculateSourcesSinksEntrypoints\r\n包含了\r\n1.从manifest.xml获得了包含entry point的所有类（是一个xml parser, 寻找类是activities, providers, services, receivers的加入）\r\n2. 从resources.arsc获得资源列表\r\n3. \r\n11 08\r\ncalculateCallbackMethodshanshu\r\n@param parser of resources.arsc\r\n0. 在AppContext里用来表示UIlayout的对象也是从resParser从提取，而FlowDroid是直接传入\r\n1. create the new iteration of the main method\r\nsoot.G.reset();\r\ninitializeSoot();\r\ncreateMainMethod();\r\n\r\n\r\n14 24\r\n2. 创建JimpleClass(entrypointClasses), 调用jimpleClass.collectCallBackMethods来获得写在source code里的call backs\r\n\r\ntransform定义（重载）后，用  PackManager.v().getPack(\"wjtp\").add(transform);加入到Soot执行过程中；再由 PackManager.v().getPack(\"wjtp\").apply();运行\r\ncollectCallBacks是发生在wjtp.ajc的一次transformation(操作)， 把只要是entryPointClasses下的method全部找出来\r\n\r\n因为call backs分为life-cycle和事件两种， entry points即life-cycle, 由于Android没有main函数，任何life-cycle都可以是入口\r\n\r\n// Find the user-defined sources in the layout XML files. \r\nlfp.parseLayoutFile(apkFileLocation, entrypoints);\r\n\r\n14 34\r\nFlowDroid paper是这么形容怎么找callbacks(此处不包含life cycle的call back)的\r\n\r\n1. 对每个component(四大)建立一张call graph\r\n\r\n2. 扫描call graph中的android 系统函数，如果系统函数接收了已知的（通过一个txt定义了的）callback 接口作为参数，则把callback接口下重载了函数作为callback methods加入存放callback method 的map<baseClass, methods>。\r\n\r\ncall backs回调函数究竟是什么？\r\n实际上和visiting patter中监视器原理一样的，Observer在Subject那里注册了自己的函数(即call back)， 当Subject的特定行为发生后，即调用Observer的call back函数。\r\n\r\n但为了符合设计模式的与接口沟通而不是直接与对象的成员，于是call back函数被写到代表这一call back的interface里，每次注册新的call back函数时先实例化call back接口并重载“真正的”call back函数。如view.OnClickListener是一个接口，它包含了需要重载的call back函数onClick()。\r\ncall back接口会作为Subject(如button)的call back接收函数（call back handler）的参数。\r\n16 44\r\nFlowDroid 最先通过ProcessManifest解析Manifest.xml，从中能提取出四大components中包含的类名, 并把它们加入到entry points\r\n\r\ncomponents 用xml 的tag来识别\r\n17 46\r\n在jimpleClasses为空时创建jimpleClasses, 调用collectCallBacks()；当不为空即循环已经开始后，调用Incremental(). \t\r\nIncremental()和非incre的区别: 前者使用了worklist算法（一个queue）.\r\n\r\nworklist algo: \r\ninit queue with start point, pop top element from queue and (re-)compute it. If it changes then enqueue all points that dep on its value; stop when queue is empty\r\n18 22\r\n\r\ngetSootClass(class) 把指定class转成SootClass: Soot内部表示Class的数据结构\r\n19 28\r\n虽然找到了callbacks寻找算法的不断更新点，但还是不理解为什么新发现的callback能作为入口能引入新的callback\t\r\n\r\n### 09 28\r\n09 14\t\r\njava序列化java.io.Serializable\r\n\r\n原理类似swap, 即内存存不下的对象，先按序存到硬盘中；后再依次读出\r\n09 16\r\nvisitor design pattern观察者模式: 判断语句类型\r\napply接收StmtSwitch的派生类对象作为参数\r\napply的派生类具体实现 e.g. \r\npublic void apply(Switch sw)\r\n{\r\n((StmtSwitch) sw).caseIfStmt(this);\r\n}\r\n当unit实际的派生类为JIfStmt时，调用apply会告诉sw“我”(this)是if语句\r\n使用寻找class hier功能；找到了所有可能的派生类。\r\n\r\n当是if语句时直接调用了 ((StmtSwitch) sw).caseIfStmt(this);\r\n而caseIfStmt(IfStmt stmt) 又被IfInstrument重载\r\n10 15\r\n分析完if语句的相关嵌入代码，剩下的tableswitch等都是类似的\t\r\ntable switch是什么语句？\r\n10 18\r\n看来tableswitch指的是https://en.wikipedia.org/wiki/Branch_table\t\r\n并不存在于高级语言中，多用于编译器后端的优化。和case-switch类似是个多路选择跳转。\r\n10 29\r\n代码同样存在大量的复制粘贴现象=。=\t\r\n复用不够啊\r\n10 38\r\ninstrumentMain(String[] args)和main(String[] args)基本一样\r\n为毛要复制一遍\r\n11 22\r\nInstead of using soot.Main.main(args);, We can use PackManager.v().runPacks(); PackManager.v().writeOutput(); to first set all the configuration, then run soot.\r\nWei Yang的个人日志主页记录了他开发的一些细节\r\nhttp://publish.illinois.edu/weiyang-david/mumbling/\r\n比如\r\n[Log] Using soot to get callgraph:\r\n\r\n1. Default CG algorithm + Add new SceneTransformer() {…}\r\n\r\n2. Spark + runPacks\r\n\r\nall with repackaged jar.\r\n\r\n11 41\r\nappcontext的ifstmt和官方教程嵌入实现方式没啥区别。只不过这里只关注if语句。因为paper里定义的context指的即if语句中出现过得变量。也就是说嵌入完成后，app运行时每次遇到了if，就把出现的变量值传进app.DummyClass，也就是嵌入进的函数，作处理。不过这个DummyClass并没有写什么东西啊(难道是反xx不完全？)。\t\r\nhttp://blog.csdn.net/zlp1992/article/details/42463463\r\n是一篇官方嵌入教程的翻译稿，里头有句/设置允许伪类（Phantom class），指的是soot为那些在其classpath找不到的类建立的模型 。\r\n对java 编译过程不大了解，不知道抽象类是否包含在里头（似乎是包含的）。\r\n\r\n什么是嵌入（instrument）?即在源码中插入代码。使得程序执行时会运行我们插入的代码，达到监测程序运行的目的。\r\n11 51\r\nECS 223 \r\nhttp://mediasite.ucdavis.edu/Mediasite/Catalog/Full/56ee0e1187b64815b6c9d0a8febe98ce21\r\n11 59\r\n现在想知道\r\n<1>. 如何通过psout找到敏感函数\r\n<2>. 如何具体通过敏感函数提取context\r\n\r\n继续分析main.py\r\n现在已经知道\r\n1. 如何生成call graph\r\n2. 如何进行嵌入；并且app context严重依赖嵌入\r\n12 07\r\nMain.py 执行流程：\r\n1. IfInstrument\r\n2. apktool解开app并把delvik bytecode -> smali\r\n3. dare：把.dek -> .class\r\n4. ICC: epicc.jar处理inter-component communication\r\n5. Main.jar\r\n\r\n12 14\r\n导入epicc.jar，找到运行此jar的入口\r\n怎么会是Main-Class: org.eclipse.jdt.internal.jarinjarloader.JarRsrcLoader。。\r\n12 20\r\n相比原生flowdroid, 多了soot.jimple.interproc.cc\r\n\r\n原来epicc是来自于\r\nhttp://siis.cse.psu.edu/epicc/installation.html\r\n和Dare是一个组做的\r\n真正的入口应该是Rsrc-Main-Class: soot.jimple.interproc.cc.Main\r\n\r\n不知Rsrc-Main和Main-Class有啥区别\r\n12 28\r\n导入Main.jar\r\n怎么和IfInstrument大小一样？\r\n测下md5\r\nmd5 不一样。还是有点区别的。\r\n\r\n大致做成jar的时候类全部导进去了。。\r\n\r\n证实了我的想法，main函数参数如果是instrument则执行instrument, 否则是factor时则跑MyTest。。\r\nMain-Class: app.Main\r\n\r\nIfStmtInstr的入口\r\nMain-Class: app.IfStmtInstrument\r\n12 37\r\n运行主要流程主要在MyTest里， 看到了Pscout, 解决<1>的答案大致在这里了。\r\n\r\n15 17 \t\r\nhttp://blog.csdn.net/mao1055229269/article/details/25827435\r\n批量删注释的方法\r\n17 16\r\n代码片段丢失。尝试了不同反xx软件后，还是会到了原点。\r\n发信问了Wei Yang。\r\n17 29 \r\n特别诡异的冲突， ConditionalResultsAvailableHandler \r\n先搁置。。\r\n17 56\r\n为什么他的能直接调用基类private成员\t\r\n比如printUsage()\r\n18 17\r\n直接把Test.java复制过来\r\n用JD反xx出来的和源码比较，发现准确率很高。除了多余的信息需要删除外，不需要额外添加。\r\n\r\n可能缺final；\r\n大段空白由于多行的变成了一行。\r\n18 46 \r\n原来他把原文件中的private改成了protected，所以才能访问。\t\r\n\r\n\r\n### 09 25\r\n08 44 \r\n设计模式\r\n\r\n15 57     \r\n看完OO Design前14章\t\r\n\r\n19 17\r\njava序列化java.io.Serializable\r\n\r\n 个大的应用程序需要保存很多对象的时候，由于虚拟机内存有限，(资源宝贵啊  )有时不可能所有有用的对象都放到内存中，因此，需要将不常用的对象暂时持久化的文件中，当需要这个对象时，再从文件把对象恢复到内存中，这就是所谓对象的序列化和反序列化。\r\n\r\n19 52\r\n多态的体现: 在扫描检查每条指令时，用的是抽象基类Unit。它的实际派生类可以是任意代表指令类型的类\r\nvisitor design pattern观察者模式: 判断语句类型\r\napply接收StmtSwitch的派生类对象作为参数\r\napply的派生类具体实现 e.g. \r\npublic void apply(Switch sw)\r\n{\r\n((StmtSwitch) sw).caseIfStmt(this);\r\n}\r\n当unit实际的派生类为JIfStmt时，调用apply会告诉sw“我”(this)是if语句\r\n\r\n### 09 24\r\n11 17\t\r\n总算在Linux下配好了，但生成的dot还是打不开啊。。\r\n\t\r\n11 54   \t把spark 的verbosse模式关了， 立马从5000+变成600条边，能打开.dot了\t\r\n12 11\t\r\n想找到sensitive method, 看看app context是怎么做的\r\n\t\r\n15 12\tMain.py执行的第一条真正的命令是instruments\t\r\nIfInstrument.jar\r\njava -jar IfInstrument.jar filepath platformPath libdir dirPath\r\n15 33\t创建了主页\thttp://majestyhao.github.io/MyFlowAnalysis/\r\n15 35\tIfInstrument.jar不含源码， 能看出包含了FlowDroid 和weka.\t\r\n\r\n16 01\r\n\t\r\njar的main method由Manifest指定\r\n\t\r\n或者\r\n\r\njar cfe Main.jar \r\nfoo.Main \r\nfoo/Main.class\r\n\r\n16 04\r\n\t\r\nMain-Class: app.IfStmtInstrument\r\n\t\r\n如何给编译好了的jar添加javadoc和source?\r\nhttp://stackoverflow.com/questions/9289617/eclipse-how-to-link-a-jar-containing-javadocs-source-with-its-binary\r\n16 47     \r\n\t\r\nOptions.v().set_allow_phantom_refs(true); 大致phantom是指指向虚类的引用   \r\n\t\r\n虚类是包含虚函数的类；虚函数为了实现多态，在动态连编时(即在compiling时载入.class)选择合适的成员函数。纯虚函数（在基类）没有实现，是为接口。\r\n17 31     \r\n\t\r\ntransform可以看成（在method body）的任何操作，不仅局限于IR之间的转换\r\n\t\r\n\r\n17 41\r\n\t\r\nUtil.Switch()用于实现visitor design pattern\r\n\t\r\nhttps://en.wikipedia.org/wiki/Visitor_pattern\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}